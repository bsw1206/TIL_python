# 리스트(중요!)

- 대괄호 안에 쉼표로 구분
- 모든 종류의 데이터를 담을 수 있음.
- 값을 자유롭게 변경 가능
- 중첩 리스트 : 다른 리스트를 값으로 가진 리스트

```python
# 리스트는 가변
# 1. 인덱싱으로 값 수정
my_list = [1, 2, 3, 4, 5]
my_list[1] = 'two'
print(my_list)  # [1, 'two', 3, 4, 5]

# 2. 슬라이싱으로 값 수정
my_list = [1, 2, 3, 4, 5]
my_list[2:4] = ['three', 'four']
print(my_list)  # [1, 2, 'three', 'four', 5]


# 이런 경우에는 재할당, 위의 경우는 수정(재할당 X)
my_list = [1, 2, 3, four, 5]

```

# 튜플
- 소괄호 안에 쉼표로 구분하여 만듬
- 모든 종류의 데이터를 담을 수 있음
- 한번 만들어지면 절대 수정할 수 없음.
- 단일 요소 튜플을 만들때는 ***반드시*** 후행쉼표를 사용해야 함. 
```python
(1,) # 단일 요소 튜플
(1) # 정수 1을 나타냄.
```
#### 튜플의 불변성
- 튜플은 절대 내용을 추가, 수정, 삭제할 수 없다. 
- 튜플의 불변 특성을 사용하여 내부 동작과 안전한 데이터 전달에 사용된다.
- 데이터의 안정성과 무결성을 보장함.
```python
# 다중 할당
x, y = 10, 20
print(x)  # 10
print(y)  # 20
# 실제 내부 동작
# (x, y) = (10, 20)



# 값 교환
x, y = 1, 2
x, y = y, x
# 실제 내부 동작
# temp = (y, x)  # 튜플 생성
# x, y = temp  # 튜플 언패킹(튜플을 풀어냄)
# print(x, y)  # 2 1
```
# range
- sequence의 일부
- 연속된 ***정수*** 시퀀스를 생성하는 변경 불가능한 자료형
- 주로 반복문과 함께 사용됨.
>range의 기본 구문
>- range(start, stop, step)
>- range(stop) 매개변수가 하나면 stop으로 인식, start는 0, step은 1이 기본값
>- range(5) = 0, 1, 2, 3, 4
>- range(start, stop) 매개변수가 두 개면 start와 stop으로 인식, stop은 1이 기본값으로 자동 설정
>- range(2, 5) = 2, 3, 4
>- step이 음수면 반대로 

- range는 list로 형변환시 내부 값을 확인 가능

### range의 규칙
- stop 값은 sequence값에 포함되지 x
- 시작 값이 끝 값보다 큰 경우 [] -> 공백, error가 나지는 않는다.
- step이 음수 : 


# dict(중요!)
- key - value **쌍**으로 이루어진 ***순서와 중복이 없는*** 변경 **가능**한 자료형
- 시퀀스가 아니고 인덱싱을 못한다!!!
- 중복이 없다!!!
- 중괄호 안에 값들이 쉼표로 구분되어 있다.
- 각 값에는 순서가 없음.
- ex. {'apple': 12, 'list': [1, 2, 3]} -> 요소 2개, 순서 x
- key : 값을 식별하기 위한 고유한 이름
- value : 키에 해당하는 실제 데이터
- 첫 번째 요소 같은 거 없다! -> 순서가 없기 때문
- 데이터에 순서가 필요 없고, 각 데이터에 의미 있는 이름(key)를 붙여 관리할 때 사용함.

### 딕셔너리 규칙
> - key의 규칙 : 고유해야 함, 변경 불가능한 자료형(str, int, float, tuple)만 사용 가능.(list, dict는 불가!)
> - value의 값은 자유롭게 사용 가능.
> - 딕셔너리 값 접근 방법 : key를 사용하여 value 꺼내오기 ***(key에 접근시 대괄호 사용!!!)***, key를 입력하면 value를 가져옴.
> - 추가하거나 변경 가능. 
```python
# 딕셔너리 값 추가 및 변경
my_dict = {'apple': 12, 'list': [1, 2, 3]}
# 추가
my_dict['banana'] = 50
print(my_dict)  # {'apple': 12, 'list': [1, 2, 3], 'banana': 50}

# 변경
my_dict['apple'] = 100
print(my_dict)  # {'apple': 100, 'list': [1, 2, 3], 'banana': 50}
```

# 세트
- 순서와 중복이 없는 변경 가능한 자료형
- 중괄호 {} 안에 값들을 쉼표로 구분하여 만듬
- {} = dict , set() = 빈 set
```python
my_set_1 = {1, 2, 3}
my_set_2 = {1, 1, 1}
print(my_set_1) # {1, 2, 3}
print(my_set_2) # {1}
```
- 집합 연산에 쓰임
```python

# 세트의 집합 연산산
my_set_1 = {1, 2, 3}
my_set_2 = {3, 6, 9}

# 합집합
print(my_set_1 | my_set_2)  # {1, 2, 3, 6, 9}

# 차집합
print(my_set_1 - my_set_2)  # {1, 2}

# 교집합
print(my_set_1 & my_set_2)  # {3}
```

# 다른 데이터 타입
- None : 값이 없음을 표현하는 데이터 타입(존재하지 않는 것은 아님.), 메모리 주소가 존재
- Boolean : 참과 거짓, 단 두 가지 값만 가지는 데이터 타입(True, False)
---
---
---
---
---
### Collection
- str, list, tuple, range, set, dict 데이터 타입이 모두 컬렉션에 분류됨.
- 여러 개으 값을 하나로 묶어 관리하는 자료형들을 통칭
- 변경 가능 여부, ***순서 존재 여부***에 따라 컬렉션 나눌 수 있음. 

#### 불변과 가변
- 불변 : 변경 불가, 안정성 예측 가능, str/tuple/range 등
- 가변 : 변경 가능, 유연성, 효율성, list/dict/set 등

##### 형변환
- 한 데이터 타입을 다른 데이터 타입으로 변환하는 과정
- 암시적 형변환(파이썬이 자동으로 처리)과 명시적 형변환(개발자가 직접 지시)이 존재

###### 암시적 형변환
- 파이썬이 연산 중에 자동으로 데이터 타입을 변환함.
- 주로 Boolean과 Numeric Type에서만 가능
```python
# 암시적 형변환
# 정수(int)와 실수(float)의 덧셈
print(3 + 5.0)  # 8.0
# 불리언(bool)과 정수(int)의 덧셈
print(True + 3)  # 4
# 불리언간의 덧셈
print(True + False)  # 1
```

###### 명시적 형변환
- 개발자가 변환하고 싶은 타입을 직접 함수로 지정하여 변환하는 것
- str -> int : 형식에 맞는 숫자만 가능
- int -> str : 모두 가능
---
---
---

# 연산자
- 산술 연산자 : 수학적 계산을 위함(-, +, *, /, //, %, **)
- 복합 연산자 : 연산과 할당이 함께 이뤄짐(+=, -=, *=, /=, //=, %=, **=)
- 비교 연산자 : 두 값을 비교하여 그 관계가 맞는지 틀리는지를 True 혹은 False로 변환(<, >, <=, >=, ==, !=, is, is not)
***- 비교 연산자에서 ==와 is의 차이점 : ( == : 값이 같은지?까지 본다, is : 메모리 주소까지 같은지를 확인함. )***
- is 대신 ==를 사용해야 하는 이유? -> is는 정체성을, ==는 가치를 비교하기 때문 / 또한 우리가 궁금한 것은 두 객체의 값이 논리적으로 같은가?를 확인하는 것이기 때문에 ==를 사용하는 것이 적합함. / is는 특수 목적(메모리 주소까지 같은지)을 위해서 사용됨.
**- is를 사용하는 경우 : 주로 싱글턴 객체를 비교할 때 사용함.**
***- 싱글턴 객체 : 특정 값에 대해 파이썬 전체에서 단 하나의 객체만 생성되어 재사용되는 특별한 객체(대표 예시 : None, True, False)***
- 논리 연산자 : 여러 개의 조건을 조합하거나, True/False 값을 반대로 뒤집을 때 사용(and, or, not이 대표적임.)/ 비교 연산자와 함께 사용 가능

###### 단축 평가
- 논리 연산에서 두 번째 피연산자를 평가하지 않고 결과를 결정하는 동작
- 코드 실행 최적화, 불필요한 연산 피하기
- 멤버십 연산자 : 특정 값이 시퀀스나 다른 컬렉션 안에 포함되는지 확인하는 연산자(in, not in 존재)
- 시퀀스형 연산자 : 시퀀스 자료형(문자열, 리스트, 튜플)에 특별한 의미로 사용(+, * 등 존재)
# 데이터 구조
- 여러 데이터를 효과적으로 사용관리 하기 위한 구조(str, list, dict...)
---
# 매서드
- 각 데이터 구조의 메서드를 호출하여 다양한 기능을 활용
- 객체에 속한 ***함수***
- 어딘가(클래스) 내부에 정의되는 함수
  ``` python
  print(type('1')) # <class 'str'> class가 타입을 이끌어내는 주체
  ```
str(객체) -> 문자열을 생성하는 과정

### 메서드 호출 방법

```python
'hello'.capitalize()
- 우리가 만든 객체(데이터)에게 원하는 명령(메서드)를 내리는 방법

numbers = [1, 2, 3]
numbers.append(4) # append가 메서드
print(numbers) # [1, 2, 3, 4]
```
# 공통 시퀀스 메서드
- s.index(x) : 시퀀스에서 첫 번째로 일치하는 항목 x의 인덱스 반환, 없으면 ValueError
- s.count(x) : 시퀀스 s에서 등장하는 항목 x의 개수를 반
- s.find(x) : **s.index(x)와의 차이점 구분하기!**
- s.isupper() : ?
- s.islower() : ?
- s.isalpha() : ?

# 문자열 조작 메서드(새로운 문자열 반환 <- 불변이기 때문!)
- str.replace(old, new[,count]) # 대괄호는 문법적이 아닌 문서적 -> 실제로 쓰면 에러남.
- str.strip([chars])
- str.split(sep=None, maxsplit=-1) : 분할하여 문자열에 있는 **리스트**를 반환, maxsplit이 주어지면, 최대 maxsplit번의 분할이 수행됨.
- str.join(iterable) : iterable의 문자열을 연결한 문자열을 **반환**

# 리스트 전용 메서드(가변 시퀀스)
- L.append(x) : 리스트 마지막에 항목 x를 추가 , append는 추가하는 것으로 끝이고 반환값이 없음!!
- L.extend(iterable) : 리스트에 다른 반복 가능한 객체의 모든 항목을 추가(숫자는 반복 가능하지 않음!)
- L.pop() : 맨 뒤에 있는 제거하고 ***반환함.***
- L.pop(i) : 인덱스 i 위치의 항목을 제거하고 **반환**
- L.insert(i, x) : 인덱스 i 위치에 x 삽입
- L.remove(x) : 리스트에서 첫 번째로 위치하는 항목을 삭제
- L.clear() : 리스트 모든 항목을 제거 -> 빈 리스트 반환
### 리스트 정렬 메서드
- L.reverse() : 리스트의 순서를 역순으로 변경 (정렬 X)
- L.sort() : 리스트를 오름차순으 **정렬**(매개변수 이용가능) (sorted와의 차이점 : sort는 리스트 전용, sorted는 내장 함수에서 이용되면서 sort와 다르게 반환값이 있다!)
``` python
# sort(내림차순 정렬)
my_list.sort(reverse=True) # 기본값은 reverse 값 = False
print(my_list)  # [100, 3, 2, 1]
```
- reverse, sort 둘다 return값은 존재하지 않는다!!


# 복사
- 가변 객체 : 내용을 변경 가능 / 불변 객체 : 내용을 변경 불가
- 할당과 재할당에서의 주소 변경 차이가 중요함.
- 메모리 주소를 보는 함수 : id() 함수 이용 
- ![alt text](image.png)
- 가변/불변 메모리 관리 방식의 이유? : 불변 객체는 여러 변수가 동일한 객체를 안전하게 공유 , 가변 객체는 내용 수정이 빈번할 때 기존 객체를 직접 수정 가능 -> 객체 생성 및 삭제에 드는 비용을 절감하여 성능 향상 ***(성능 최적화)***

## 얕은 복사
- 객체 최상위 요소만 새로운 메모리에 복사하는 방법
- 함정 (가변 객체) : 1차원 리스트에서는 상관이 없지만, 2차원 리스트에서는 문제가 생김.(최상위만 복사하고 나머지는 그대로 원본의 메모리 주소를 따름.)

## 깊은 복사
- 중첩된 객체까지 모두 새로운 객체로 생성됨.
- 객체의 모든 수준의 요소를 새로운 메모리에 저장하는 방법
- 모듈을 사용해야 함.
  ```python
  import copy
  new_object = copy.deepcopy(original_object)
  ```

  ### List Comprehension
  - 간결하고 효율적인 리스트 생성 방법
  - [expression for 변수 in iterable if 조건식] # if 조건 부분은 선택사항
  - 원래 여러줄의 for문을 한 줄로 정리가 가능하다.
  - 여러 조건이 나열되는 경우에는 사용하기가 불편할 수 있다.
  ##### 리스트를 생성하는 3가지 방법
  - loop, list comprehension, map 이용
  - 코드의 가독성과 유지 보수성을 고려하여 성능 차이를 매긴다. 대부분의 경우 마이크로초 단위로 미미함. 


# 매서드 체이닝
- 여러 메서드를 연속해서 출력하는 방법
- 주의사항 : 메서드가 객체를 반환할 때만 메서드 체이닝이 가능
- 안되는 메서드 : append(), sort()

